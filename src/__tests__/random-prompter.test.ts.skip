import { describe, it, expect, vi, beforeEach, beforeAll } from "vitest";
import "./test-setup";  // Import mocks from test setup

// We need to import this before TreeNode to avoid import errors
beforeAll(() => {
  // Mock Plotly.on with a more specific implementation
  window.Plotly = {
    newPlot: vi.fn(() => ({ on: vi.fn() })),
    on: vi.fn(),
  };
  
  // Set a global to indicate we're in a test environment
  global.__TEST__ = true;
});

// Now import the module under test
import { TreeNode, UT } from "../random-prompter";

// Get the breadth_first_walk function from the exported UT object
const { breadth_first_walk } = UT;

describe("TreeNode and Tree Traversal", () => {
  describe("TreeNode class", () => {
    it("should create a node with default properties", () => {
      const node = new TreeNode({ name: "Test Node" });
      
      expect(node.name).toBe("Test Node");
      expect(node.value).toBe(25); // Default value
      expect(node.children).toEqual([]); // Empty children array
    });

    it("should create a node with provided properties", () => {
      const node = new TreeNode({
        name: "Parent",
        value: 100,
        children: [
          new TreeNode({ name: "Child 1" }),
          new TreeNode({ name: "Child 2" }),
        ],
      });
      
      expect(node.name).toBe("Parent");
      expect(node.value).toBe(100);
      expect(node.children.length).toBe(2);
      expect(node.children[0].name).toBe("Child 1");
      expect(node.children[1].name).toBe("Child 2");
    });

    it("should shuffle children during construction", () => {
      // Mock the shuffle function to verify it's called
      const originalShuffle = UT.shuffle;
      UT.shuffle = vi.fn(arr => arr);
      
      const children = [
        new TreeNode({ name: "Child 1" }),
        new TreeNode({ name: "Child 2" }),
        new TreeNode({ name: "Child 3" }),
      ];
      
      new TreeNode({
        name: "Parent",
        children,
      });
      
      expect(UT.shuffle).toHaveBeenCalledWith(children);
      
      // Restore original shuffle
      UT.shuffle = originalShuffle;
    });
  });

  describe("breadth_first_walk", () => {
    let tree: TreeNode;
    
    beforeEach(() => {
      // Create a test tree
      //       Root
      //      /    \
      //   Child1  Child2
      //    /
      // GrandChild
      
      const grandChild = new TreeNode({ name: "GrandChild" });
      const child1 = new TreeNode({
        name: "Child1",
        children: [grandChild],
      });
      const child2 = new TreeNode({ name: "Child2" });
      
      tree = new TreeNode({
        name: "Root",
        children: [child1, child2],
      });
      
      // Mock shuffle to ensure consistent order during tests
      vi.spyOn(UT, 'shuffle').mockImplementation(arr => arr);
    });

    it("should return nothing for null tree", () => {
      const walker = breadth_first_walk(null);
      const result = Array.from(walker);
      expect(result).toEqual([]);
    });

    it("should traverse tree in breadth-first order", () => {
      const walker = breadth_first_walk(tree);
      const nodes = Array.from(walker).map(([node, _]) => node.name);
      
      expect(nodes).toEqual(["Root", "Child1", "Child2", "GrandChild"]);
    });

    it("should provide parent references during traversal", () => {
      const walker = breadth_first_walk(tree);
      const nodeParentPairs = Array.from(walker).map(([node, parent]) => ({
        node: node.name,
        parent: parent?.name,
      }));
      
      expect(nodeParentPairs).toEqual([
        { node: "Root", parent: null },
        { node: "Child1", parent: "Root" },
        { node: "Child2", parent: "Root" },
        { node: "GrandChild", parent: "Child1" },
      ]);
    });

    it("should handle a single node tree", () => {
      const singleNode = new TreeNode({ name: "Single" });
      const walker = breadth_first_walk(singleNode);
      const result = Array.from(walker);
      
      expect(result.length).toBe(1);
      expect(result[0][0].name).toBe("Single");
      expect(result[0][1]).toBeNull();
    });

    it("should handle nodes with no children properly", () => {
      // Create a leaf node
      const leaf = new TreeNode({ name: "Leaf" });
      const walker = breadth_first_walk(leaf);
      const result = Array.from(walker);
      
      expect(result.length).toBe(1);
      expect(result[0][0].name).toBe("Leaf");
    });
  });
});